module main
{
  type router_id_t = bv4;
  type stage_t = bv3;
  type packet_t = record {
    source : integer,
    d1 : integer,
    d2 : integer,
    d3 : integer,
    destination : integer,
    previous_location : integer,
    current_location : integer,
    next_location : integer,
    stage : stage_t
  };

  define valid_stage(s : stage_t) : boolean =
    (s >= 1bv3 && s <= 5bv3);

  define valid_packet(p : packet_t) : boolean =
    p.source != p.d1 && p.d1 != p.d2 && p.d2 != p.d3 && p.d3 != p.destination && p.destination != p.source && valid_stage(p.stage);

  var packets : [integer]packet_t;
  const num_packets : integer = 4;

  procedure find_next_location(pin : packet_t)
    returns (pout : packet_t)
    modifies packets;
  {
    pout = pin;
    case
      (pin.stage == 1bv3) : {
        pout.previous_location = -1;
	pout.current_location = pin.source;
	pout.next_location = pin.d1;
      }
       (pin.stage == 2bv3) : {
        pout.previous_location = pin.source;
	pout.current_location = pin.d1;
	pout.next_location = pin.d2;
      }
       (pin.stage == 3bv3) : {
        pout.previous_location = pin.d1;
	pout.current_location = pin.d2;
	pout.next_location = pin.d3;
      }
       (pin.stage == 4bv3) : {
        pout.previous_location = pin.d2;
	pout.current_location = pin.d3;
	pout.next_location = pin.destination;
      }
       (pin.stage == 5bv3) : {
        pout.previous_location = pin.d3;
	pout.current_location = pin.destination;
	pout.next_location = -1;
      }
    
    esac
  }
  procedure move_packets()
    modifies packets;
  {
    for (i : integer) in range(0, num_packets) {
      if ((packets[i]).stage <= 5bv3) {
        var p : packet_t;
        p = packets[i];
        p.stage = p.stage + 1bv3;
	call (packets[i]) = find_next_location(p);
      }
    }
  }
  init {
      for (i : integer) in range(0, num_packets) {
      var p : packet_t;
      p = packets[i];
      assume (p.d1 >= 1 && p.d1 <= 10 );
      assume (p.d2 >= 1 && p.d2 <= 10 );
      assume (p.d3 >= 1 && p.d3 <= 10 );
      assume valid_packet(packets[i]);
    }
  }
  next {
    call move_packets();
  }
  assume p : true;
  invariant always_false: false;
  control {
    v = unroll(2);
    check;
    print_results;
    v.print_cex(
      (packets[0]).previous_location, (packets[0]).current_location, (packets[0]).next_location, (packets[0]).stage,
      (packets[1]).previous_location, (packets[1]).current_location, (packets[1]).next_location, (packets[1]).stage,
      (packets[2]).previous_location, (packets[2]).current_location, (packets[2]).next_location, (packets[2]).stage,
      (packets[3]).previous_location, (packets[3]).current_location, (packets[3]).next_location, (packets[3]).stage

    );
  }
}
